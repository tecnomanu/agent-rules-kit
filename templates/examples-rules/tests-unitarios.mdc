---
description:
globs:
alwaysApply: true
---

# Tests Unitarios para la API de ChatRobot

Este documento describe la implementación de los tests unitarios para la API de ChatRobot utilizando el marco de pruebas de Laravel.

## Estructura de los Tests

Los tests unitarios se organizan en dos carpetas principales:

1. `tests/Unit`: Para tests unitarios de componentes individuales
2. `tests/Feature`: Para tests de integración que prueban el flujo completo

## Configuración del Entorno de Pruebas

Laravel proporciona un archivo `.env.testing` para configurar el entorno de pruebas:

```
APP_ENV=testing
DB_CONNECTION=sqlite
DB_DATABASE=:memory:
```

## Uso del patrón RefreshDatabase

Los tests utilizan el trait `RefreshDatabase` para asegurar que cada test se ejecute con una base de datos limpia:

```php
use Illuminate\Foundation\Testing\RefreshDatabase;

class MiTest extends TestCase
{
    use RefreshDatabase;

    // ...
}
```

## Tests de Autenticación API

Los tests de autenticación validan el funcionamiento de los endpoints de login, logout y obtención del usuario autenticado:

```php
namespace Tests\Feature\Auth;

use App\Models\User;
use Database\Seeders\RoleSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use Tests\TestCase;

class AuthenticationTest extends TestCase
{
    use RefreshDatabase;

    protected function setUp(): void
    {
        parent::setUp();

        // Ejecutar el seeder de roles para asegurar que los usuarios tengan roles válidos
        $this->seed(RoleSeeder::class);
    }

    public function test_users_can_login_with_valid_credentials()
    {
        // Crear un usuario para hacer login
        $user = User::factory()->create([
            'email' => 'test@example.com',
            'password' => bcrypt('password'),
            'role_id' => \App\Models\Role::where('name', 'agent_user')->first()->id,
        ]);

        // Hacemos la petición de login
        $response = $this->postJson('/api/login', [
            'email' => 'test@example.com',
            'password' => 'password',
        ]);

        // Verificamos que la respuesta sea exitosa
        $response->assertStatus(200);

        // Verificamos que se devuelva un token
        $this->assertArrayHasKey('token', $response->json());
    }

    // ...otros tests de autenticación
}
```

### Uso de Sanctum para Autenticación en Tests

Para probar endpoints protegidos, utilizamos `Sanctum::actingAs()`:

```php
public function test_authenticated_users_can_get_their_info()
{
    // Creamos un usuario
    $user = User::factory()->create([
        'role_id' => \App\Models\Role::where('name', 'agent_user')->first()->id,
    ]);

    // Autenticamos al usuario con Sanctum
    Sanctum::actingAs($user);

    // Hacemos la petición para obtener información del usuario
    $response = $this->getJson('/api/user');

    // Verificamos que la respuesta sea exitosa y contenga los datos del usuario
    $response->assertStatus(200)
        ->assertJsonFragment([
            'id' => $user->id,
            'email' => $user->email,
        ]);
}
```

## Tests de Recursos de API

### Tests de Tenants

Los tests de tenants verifican las operaciones CRUD sobre los tenants:

```php
namespace Tests\Feature\Tenant;

use App\Models\Role;
use App\Models\Tenant;
use App\Models\User;
use Database\Seeders\RoleSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use Tests\TestCase;

class TenantTest extends TestCase
{
    use RefreshDatabase;

    protected User $admin;

    protected function setUp(): void
    {
        parent::setUp();

        // Ejecutar el seeder de roles
        $this->seed(RoleSeeder::class);

        // Obtener el rol superadmin
        $superadminRole = Role::where('name', 'superadmin')->first();

        // Crear un usuario superadmin
        $this->admin = User::factory()->create([
            'role_id' => $superadminRole->id,
        ]);
    }

    public function test_superadmin_can_list_tenants()
    {
        // Crear algunos tenants
        Tenant::factory()->count(3)->create();

        // Autenticar al usuario con Sanctum
        Sanctum::actingAs($this->admin);

        $response = $this->getJson('/api/tenants');

        $response->assertStatus(200)
            ->assertJsonCount(3, 'data');
    }

    // ...otros tests de tenants
}
```

### Tests de Chats

Los tests de chats verifican las operaciones sobre los chats y el widget público:

```php
namespace Tests\Feature\Chat;

use App\Models\Chat;
use App\Models\Role;
use App\Models\Tenant;
use App\Models\User;
use Database\Seeders\RoleSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use Tests\TestCase;

class ChatTest extends TestCase
{
    use RefreshDatabase;

    protected User $admin;
    protected Tenant $tenant;

    protected function setUp(): void
    {
        parent::setUp();

        // Ejecutar el seeder de roles
        $this->seed(RoleSeeder::class);

        // Crear un tenant
        $this->tenant = Tenant::factory()->create();

        // Obtener el rol admin
        $adminRole = Role::where('name', 'company_admin')->first();

        // Crear un usuario admin
        $this->admin = User::factory()->create([
            'role_id' => $adminRole->id,
            'tenant_id' => $this->tenant->id,
        ]);
    }

    public function test_get_chat_by_hash_for_widget()
    {
        $chat = Chat::factory()->create([
            'tenant_id' => $this->tenant->id,
            'hash' => 'chat-hash-123',
            'active' => true,
        ]);

        $response = $this->getJson("/api/widget/chats/{$chat->hash}");

        $response->assertStatus(200)
            ->assertJson([
                'data' => [
                    'id' => $chat->id,
                    'name' => $chat->name,
                ]
            ]);
    }

    // ...otros tests de chats
}
```

## Factories para Tests

Se han creado factories para todos los modelos principales, lo que facilita la creación de datos de prueba:

### Tenant Factory

```php
class TenantFactory extends Factory
{
    public function definition(): array
    {
        return [
            'name' => $this->faker->company(),
            'type' => $this->faker->randomElement(['COMPANY', 'RESELLER', 'FRANCHISE']),
            'status' => 'active',
            'settings' => [
                'primary_color' => $this->faker->hexColor(),
                'short_name' => $this->faker->word(),
            ],
            // ...otros campos
        ];
    }

    // Estados específicos
    public function company(): static
    {
        return $this->state(fn (array $attributes) => [
            'type' => 'COMPANY',
        ]);
    }

    // ...otros estados
}
```

### Chat Factory

```php
class ChatFactory extends Factory
{
    public function definition(): array
    {
        $types = ['lead_capture', 'assistance', 'custom'];
        $type = $this->faker->randomElement($types);

        $requiredFields = [];
        if ($type === 'lead_capture') {
            $requiredFields = ['name', 'email', 'phone'];
        } elseif ($type === 'assistance') {
            $requiredFields = ['email'];
        }

        return [
            'tenant_id' => Tenant::factory(),
            'hash' => Str::uuid()->toString(),
            'name' => $this->faker->sentence(3),
            'prompt' => $this->faker->paragraph(),
            'type' => $type,
            'required_fields' => $requiredFields,
            // ...otros campos
        ];
    }

    // ...estados específicos
}
```

## Seeders Compartidos

Para facilitar los tests y evitar problemas de duplicación, se utilizan seeders compartidos entre la aplicación y los tests:

```php
class RoleSeeder extends Seeder
{
    public function run(): void
    {
        // Lista de roles predefinidos
        $roles = [
            ['name' => 'superadmin'],
            ['name' => 'company_admin'],
            ['name' => 'agent_user'],
        ];

        // Crear cada rol solo si no existe
        foreach ($roles as $role) {
            Role::firstOrCreate(
                ['name' => $role['name']],
                $role
            );
        }
    }
}
```

## Desactivación de Tests Problemáticos

Para tests que requieren configuración específica o que dependen de servicios externos, se utiliza `markTestSkipped`:

```php
public function test_start_conversation()
{
    $this->markTestSkipped('Problema con OpenAIService en entorno de pruebas');

    // ...resto del test
}
```

## Ejecutando los Tests

Para ejecutar todos los tests:

```bash
php artisan test
```

Para ejecutar un grupo específico de tests:

```bash
php artisan test --group=tenant
```

Para ejecutar un test específico:

```bash
php artisan test --filter=test_superadmin_can_list_tenants
```

## Mocking de Servicios Externos

Para servicios como OpenAI, se recomienda crear mocks en los tests:

```php
public function test_generate_chat_response()
{
    // Crear mock del servicio OpenAI
    $openAIServiceMock = $this->mock(OpenAIService::class);

    // Configurar el comportamiento esperado
    $openAIServiceMock->shouldReceive('generateChatCompletion')
        ->once()
        ->andReturn([
            'role' => 'assistant',
            'content' => 'Respuesta de prueba'
        ]);

    // ...resto del test utilizando el mock
}
```

## Mejores prácticas

1. **Base de datos separada**: Usar SQLite en memoria para tests
2. **Aislamiento**: Cada test debe ser independiente
3. **Factories**: Usar factories para crear datos de prueba
4. **Transacciones**: Usar RefreshDatabase para limpiar la base de datos entre tests
5. **Aserciones específicas**: Verificar específicamente lo que se quiere probar
6. **Mocking**: Simular servicios externos y dependencias
7. **Lectura clara**: Los tests deben ser fáciles de entender, usar nombres descriptivos
